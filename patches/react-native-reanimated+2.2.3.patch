diff --git a/node_modules/react-native-reanimated/plugin.js b/node_modules/react-native-reanimated/plugin.js
index 1bf9f1d..f15b18d 100644
--- a/node_modules/react-native-reanimated/plugin.js
+++ b/node_modules/react-native-reanimated/plugin.js
@@ -1,11 +1,8 @@
 'use strict';
-
 const generate = require('@babel/generator').default;
 const hash = require('string-hash-64');
-const { visitors } = require('@babel/traverse');
 const traverse = require('@babel/traverse').default;
-const parse = require('@babel/parser').parse;
-
+const { transformSync } = require('@babel/core');
 /**
  * holds a map of function names as keys and array of argument indexes as values which should be automatically workletized(they have to be functions)(starting from 0)
  */
@@ -37,6 +34,15 @@ const globals = new Set([
   'Date',
   'Array',
   'ArrayBuffer',
+  'Int8Array',
+  'Int16Array',
+  'Int32Array',
+  'Uint8Array',
+  'Uint8ClampedArray',
+  'Uint16Array',
+  'Uint32Array',
+  'Float32Array',
+  'Float64Array',
   'Date',
   'HermesInternal',
   'JSON',
@@ -63,10 +69,14 @@ const globals = new Set([
   'global',
   '_measure',
   '_scrollTo',
+  '_setGestureState',
   '_getCurrentTime',
   '_eventTimestamp',
   '_frameTimestamp',
   'isNaN',
+  'LayoutAnimationRepository',
+  '_stopObservingProgress',
+  '_startObservingProgress',
 ]);
 
 // leaving way to avoid deep capturing by adding 'stopCapturing' to the blacklist
@@ -121,6 +131,36 @@ const blacklistedFunctions = new Set([
   'apply',
   'call',
   '__callAsync',
+  'includes',
+]);
+
+const possibleOptFunction = new Set(['interpolate']);
+
+const gestureHandlerGestureObjects = new Set([
+  // from https://github.com/software-mansion/react-native-gesture-handler/blob/new-api/src/handlers/gestures/gestureObjects.ts
+  'Tap',
+  'Pan',
+  'Pinch',
+  'Rotation',
+  'Fling',
+  'LongPress',
+  'ForceTouch',
+  'Native',
+  'Custom',
+  'Race',
+  'Simultaneous',
+  'Exclusive',
+]);
+
+const gestureHandlerBuilderMethods = new Set([
+  'onBegin',
+  'onStart',
+  'onEnd',
+  'onUpdate',
+  'onTouchesDown',
+  'onTouchesMove',
+  'onTouchesUp',
+  'onTouchesCancelled',
 ]);
 
 class ClosureGenerator {
@@ -255,7 +295,7 @@ function buildWorkletString(t, fun, closureVariables, name) {
     ]);
   }
 
-  fun.traverse({
+  traverse(fun, {
     enter(path) {
       t.removeComments(path.node);
     },
@@ -263,29 +303,77 @@ function buildWorkletString(t, fun, closureVariables, name) {
 
   const workletFunction = t.functionExpression(
     t.identifier(name),
-    fun.node.params,
-    prependClosureVariablesIfNecessary(closureVariables, fun.get('body').node)
+    fun.program.body[0].expression.params,
+    prependClosureVariablesIfNecessary(
+      closureVariables,
+      fun.program.body[0].expression.body
+    )
   );
 
   return generate(workletFunction, { compact: true }).code;
 }
 
-function processWorkletFunction(t, fun, fileName) {
-  if (!t.isFunctionParent(fun)) {
-    return;
+function makeWorkletName(t, fun) {
+  if (t.isObjectMethod(fun)) {
+    return fun.node.key.name;
   }
+  if (t.isFunctionDeclaration(fun)) {
+    return fun.node.id.name;
+  }
+  if (t.isFunctionExpression(fun) && t.isIdentifier(fun.node.id)) {
+    return fun.node.id.name;
+  }
+  return '_f'; // fallback for ArrowFunctionExpression and unnamed FunctionExpression
+}
 
-  const functionName = fun.node.id ? fun.node.id.name : '_f';
+function makeWorklet(t, fun, fileName) {
+  // Returns a new FunctionExpression which is a workletized version of provided
+  // FunctionDeclaration, FunctionExpression, ArrowFunctionExpression or ObjectMethod.
+
+  const functionName = makeWorkletName(t, fun);
 
   const closure = new Map();
   const outputs = new Set();
   const closureGenerator = new ClosureGenerator();
+  const options = {};
+
+  // remove 'worklet'; directive before calling .toString()
+  fun.traverse({
+    DirectiveLiteral(path) {
+      if (path.node.value === 'worklet' && path.getFunctionParent() === fun) {
+        path.parentPath.remove();
+      }
+    },
+  });
 
   // We use copy because some of the plugins don't update bindings and
   // some even break them
-  const astWorkletCopy = parse('\n(' + fun.toString() + '\n)');
 
-  traverse(astWorkletCopy, {
+  const code =
+    '\n(' + (t.isObjectMethod(fun) ? 'function ' : '') + fun.toString() + '\n)';
+
+  const transformed = transformSync(code, {
+    filename: fileName,
+    presets: ['@babel/preset-typescript'],
+    plugins: [
+      '@babel/plugin-transform-shorthand-properties',
+      '@babel/plugin-transform-arrow-functions',
+      '@babel/plugin-proposal-optional-chaining',
+      '@babel/plugin-proposal-nullish-coalescing-operator',
+      ['@babel/plugin-transform-template-literals', { loose: true }],
+    ],
+    ast: true,
+    babelrc: false,
+    configFile: false,
+  });
+  if (
+    fun.parent &&
+    fun.parent.callee &&
+    fun.parent.callee.name === 'useAnimatedStyle'
+  ) {
+    options.optFlags = isPossibleOptimization(transformed.ast);
+  }
+  traverse(transformed.ast, {
     ReferencedIdentifier(path) {
       const name = path.node.name;
       if (globals.has(name) || (fun.node.id && fun.node.id.name === name)) {
@@ -296,7 +384,8 @@ function processWorkletFunction(t, fun, fileName) {
 
       if (
         parentNode.type === 'MemberExpression' &&
-        (parentNode.property === path.node && !parentNode.computed)
+        parentNode.property === path.node &&
+        !parentNode.computed
       ) {
         return;
       }
@@ -321,7 +410,7 @@ function processWorkletFunction(t, fun, fileName) {
       closureGenerator.addPath(name, path);
     },
     AssignmentExpression(path) {
-      // test for <somethin>.value = <something> expressions
+      // test for <something>.value = <something> expressions
       const left = path.node.left;
       if (
         t.isMemberExpression(left) &&
@@ -333,24 +422,22 @@ function processWorkletFunction(t, fun, fileName) {
     },
   });
 
-  fun.traverse({
-    DirectiveLiteral(path) {
-      if (path.node.value === 'worklet' && path.getFunctionParent() === fun) {
-        path.parentPath.remove();
-      }
-    },
-  });
   const variables = Array.from(closure.values());
 
   const privateFunctionId = t.identifier('_f');
-
-  // if we don't clone other modules won't process parts of newFun defined below
-  // this is weird but couldn't find a better way to force transform helper to
-  // process the function
   const clone = t.cloneNode(fun.node);
-  const funExpression = t.functionExpression(null, clone.params, clone.body);
-
-  const funString = buildWorkletString(t, fun, variables, functionName);
+  let funExpression;
+  if (clone.body.type === 'BlockStatement') {
+    funExpression = t.functionExpression(null, clone.params, clone.body);
+  } else {
+    funExpression = clone;
+  }
+  const funString = buildWorkletString(
+    t,
+    transformed.ast,
+    variables,
+    functionName
+  );
   const workletHash = hash(funString);
 
   const loc = fun && fun.node && fun.node.loc && fun.node.loc.start;
@@ -361,77 +448,100 @@ function processWorkletFunction(t, fun, fileName) {
     }
   }
 
-  const newFun = t.functionExpression(
-    fun.id,
-    [],
-    t.blockStatement([
-      t.variableDeclaration('const', [
-        t.variableDeclarator(privateFunctionId, funExpression),
-      ]),
-      t.expressionStatement(
-        t.assignmentExpression(
-          '=',
-          t.memberExpression(
-            privateFunctionId,
-            t.identifier('_closure'),
-            false
-          ),
-          closureGenerator.generate(t, variables, closure.keys())
-        )
-      ),
-      t.expressionStatement(
-        t.assignmentExpression(
-          '=',
-          t.memberExpression(
-            privateFunctionId,
-            t.identifier('asString'),
-            false
-          ),
-          t.stringLiteral(funString)
-        )
-      ),
-      t.expressionStatement(
-        t.assignmentExpression(
-          '=',
-          t.memberExpression(
-            privateFunctionId,
-            t.identifier('__workletHash'),
-            false
-          ),
-          t.numericLiteral(workletHash)
-        )
-      ),
+  const statements = [
+    t.variableDeclaration('const', [
+      t.variableDeclarator(privateFunctionId, funExpression),
+    ]),
+    t.expressionStatement(
+      t.assignmentExpression(
+        '=',
+        t.memberExpression(privateFunctionId, t.identifier('_closure'), false),
+        closureGenerator.generate(t, variables, closure.keys())
+      )
+    ),
+    t.expressionStatement(
+      t.assignmentExpression(
+        '=',
+        t.memberExpression(privateFunctionId, t.identifier('asString'), false),
+        t.stringLiteral(funString)
+      )
+    ),
+    t.expressionStatement(
+      t.assignmentExpression(
+        '=',
+        t.memberExpression(
+          privateFunctionId,
+          t.identifier('__workletHash'),
+          false
+        ),
+        t.numericLiteral(workletHash)
+      )
+    ),
+    t.expressionStatement(
+      t.assignmentExpression(
+        '=',
+        t.memberExpression(
+          privateFunctionId,
+          t.identifier('__location'),
+          false
+        ),
+        t.stringLiteral(fileName)
+      )
+    ),
+  ];
+
+  if (options && options.optFlags) {
+    statements.push(
       t.expressionStatement(
         t.assignmentExpression(
           '=',
           t.memberExpression(
             privateFunctionId,
-            t.identifier('__location'),
-            false
-          ),
-          t.stringLiteral(fileName)
-        )
-      ),
-      t.expressionStatement(
-        t.callExpression(
-          t.memberExpression(
-            t.identifier('global'),
-            t.identifier('__reanimatedWorkletInit'),
+            t.identifier('__optimalization'),
             false
           ),
-          [privateFunctionId]
+          t.numericLiteral(options.optFlags)
         )
-      ),
-      t.returnStatement(privateFunctionId),
-    ])
+      )
+    );
+  }
+
+  statements.push(
+    t.expressionStatement(
+      t.callExpression(
+        t.memberExpression(
+          t.identifier('global'),
+          t.identifier('__reanimatedWorkletInit'),
+          false
+        ),
+        [privateFunctionId]
+      )
+    )
   );
+  statements.push(t.returnStatement(privateFunctionId));
+
+  const newFun = t.functionExpression(fun.id, [], t.blockStatement(statements));
+
+  return newFun;
+}
+
+function processWorkletFunction(t, fun, fileName) {
+  // Replaces FunctionDeclaration, FunctionExpression or ArrowFunctionExpression
+  // with a workletized version of itself.
+
+  if (!t.isFunctionParent(fun)) {
+    return;
+  }
+
+  const newFun = makeWorklet(t, fun, fileName);
 
   const replacement = t.callExpression(newFun, []);
+
   // we check if function needs to be assigned to variable declaration.
   // This is needed if function definition directly in a scope. Some other ways
   // where function definition can be used is for example with variable declaration:
   // const ggg = function foo() { }
-  // ^ in such a case we don't need to definte variable for the function
+  // ^ in such a case we don't need to define variable for the function
   const needDeclaration =
     t.isScopable(fun.parent) || t.isExportNamedDeclaration(fun.parent);
   fun.replaceWith(
@@ -443,6 +553,23 @@ function processWorkletFunction(t, fun, fileName) {
   );
 }
 
+function processWorkletObjectMethod(t, path, fileName) {
+  // Replaces ObjectMethod with a workletized version of itself.
+
+  if (!t.isFunctionParent(path)) {
+    return;
+  }
+
+  const newFun = makeWorklet(t, path, fileName);
+
+  const replacement = t.objectProperty(
+    t.identifier(path.node.key.name),
+    t.callExpression(newFun, [])
+  );
+
+  path.replaceWith(replacement);
+}
+
 function processIfWorkletNode(t, fun, fileName) {
   fun.traverse({
     DirectiveLiteral(path) {
@@ -468,6 +595,115 @@ function processIfWorkletNode(t, fun, fileName) {
   });
 }
 
+function processIfGestureHandlerEventCallbackFunctionNode(t, fun, fileName) {
+  // Auto-workletizes React Native Gesture Handler callback functions.
+  // Detects `Gesture.Tap().onEnd(<fun>)` or similar, but skips `something.onEnd(<fun>)`.
+  // Supports method chaining as well, e.g. `Gesture.Tap().onStart(<fun1>).onUpdate(<fun2>).onEnd(<fun3>)`.
+
+  // Example #1: `Gesture.Tap().onEnd(<fun>)`
+  /*
+  CallExpression(
+    callee: MemberExpression(
+      object: CallExpression(
+        callee: MemberExpression(
+          object: Identifier('Gesture')
+          property: Identifier('Tap')
+        )
+      )
+      property: Identifier('onEnd')
+    )
+    arguments: [fun]
+  )
+  */
+
+  // Example #2: `Gesture.Tap().onStart(<fun1>).onUpdate(<fun2>).onEnd(<fun3>)`
+  /*
+  CallExpression(
+    callee: MemberExpression(
+      object: CallExpression(
+        callee: MemberExpression(
+          object: CallExpression(
+            callee: MemberExpression(
+              object: CallExpression(
+                callee: MemberExpression(
+                  object: Identifier('Gesture')
+                  property: Identifier('Tap')
+                )
+              )
+              property: Identifier('onStart')
+            )
+            arguments: [fun1]
+          )
+          property: Identifier('onUpdate')
+        )
+        arguments: [fun2]
+      )
+      property: Identifier('onEnd')
+    )
+    arguments: [fun3]
+  )
+  */
+
+  if (
+    t.isCallExpression(fun.parent) &&
+    isGestureObjectEventCallbackMethod(t, fun.parent.callee)
+  ) {
+    processWorkletFunction(t, fun, fileName);
+  }
+}
+
+function isGestureObjectEventCallbackMethod(t, node) {
+  // Checks if node matches the pattern `Gesture.Foo()[*].onBar`
+  // where `[*]` represents any number of method calls.
+  return (
+    t.isMemberExpression(node) &&
+    t.isIdentifier(node.property) &&
+    gestureHandlerBuilderMethods.has(node.property.name) &&
+    containsGestureObject(t, node.object)
+  );
+}
+
+function containsGestureObject(t, node) {
+  // Checks if node matches the pattern `Gesture.Foo()[*]`
+  // where `[*]` represents any number of chained method calls, like `.something(42)`.
+
+  // direct call
+  if (isGestureObject(t, node)) {
+    return true;
+  }
+
+  // method chaining
+  if (
+    t.isCallExpression(node) &&
+    t.isMemberExpression(node.callee) &&
+    containsGestureObject(t, node.callee.object)
+  ) {
+    return true;
+  }
+
+  return false;
+}
+
+function isGestureObject(t, node) {
+  // Checks if node matches `Gesture.Tap()` or similar.
+  /*
+  node: CallExpression(
+    callee: MemberExpression(
+      object: Identifier('Gesture')
+      property: Identifier('Tap')
+    )
+  )
+  */
+  return (
+    t.isCallExpression(node) &&
+    t.isMemberExpression(node.callee) &&
+    t.isIdentifier(node.callee.object) &&
+    node.callee.object.name === 'Gesture' &&
+    t.isIdentifier(node.callee.property) &&
+    gestureHandlerGestureObjects.has(node.callee.property.name)
+  );
+}
+
 function processWorklets(t, path, fileName) {
   const name =
     path.node.callee.type === 'MemberExpression'
@@ -477,17 +713,14 @@ function processWorklets(t, path, fileName) {
     objectHooks.has(name) &&
     path.get('arguments.0').type === 'ObjectExpression'
   ) {
-    const objectPath = path.get('arguments.0.properties.0');
-    if (!objectPath) {
-      // edge case empty object
-      return;
-    }
-    for (let i = 0; i < objectPath.container.length; i++) {
-      processWorkletFunction(
-        t,
-        objectPath.getSibling(i).get('value'),
-        fileName
-      );
+    const properties = path.get('arguments.0.properties');
+    for (const property of properties) {
+      if (t.isObjectMethod(property)) {
+        processWorkletObjectMethod(t, property, fileName);
+      } else {
+        const value = property.get('value');
+        processWorkletFunction(t, value, fileName);
+      }
     }
   } else {
     const indexes = functionArgsToWorkletize.get(name);
@@ -499,86 +732,55 @@ function processWorklets(t, path, fileName) {
   }
 }
 
-const PLUGIN_BLACKLIST_NAMES = ['@babel/plugin-transform-object-assign'];
-
-const PLUGIN_BLACKLIST = PLUGIN_BLACKLIST_NAMES.map((pluginName) => {
-  try {
-    const blacklistedPluginObject = require(pluginName);
-    // All Babel polyfills use the declare method that's why we can create them like that.
-    // https://github.com/babel/babel/blob/32279147e6a69411035dd6c43dc819d668c74466/packages/babel-helper-plugin-utils/src/index.js#L1
-    const blacklistedPlugin = blacklistedPluginObject.default({
-      assertVersion: (_x) => true,
-    });
-
-    visitors.explode(blacklistedPlugin.visitor);
-    return blacklistedPlugin;
-  } catch (e) {
-    console.warn(`Plugin ${pluginName} couldn't be removed!`);
-  }
-});
+const FUNCTIONLESS_FLAG = 0b00000001;
+const STATEMENTLESS_FLAG = 0b00000010;
 
-// plugin objects are created by babel internals and they don't carry any identifier
-function removePluginsFromBlacklist(plugins) {
-  PLUGIN_BLACKLIST.forEach((blacklistedPlugin) => {
-    if (!blacklistedPlugin) {
-      return;
-    }
-
-    const toRemove = [];
-    for (let i = 0; i < plugins.length; i++) {
-      if (
-        JSON.stringify(Object.keys(plugins[i].visitor)) !==
-        JSON.stringify(Object.keys(blacklistedPlugin.visitor))
-      ) {
-        continue;
-      }
-      let areEqual = true;
-      for (const key of Object.keys(blacklistedPlugin.visitor)) {
-        if (
-          blacklistedPlugin.visitor[key].toString() !==
-          plugins[i].visitor[key].toString()
-        ) {
-          areEqual = false;
-          break;
-        }
+function isPossibleOptimization(fun) {
+  let isFunctionCall = false;
+  let isStatement = false;
+  traverse(fun, {
+    CallExpression(path) {
+      if (!possibleOptFunction.has(path.node.callee.name)) {
+        isFunctionCall = true;
       }
-
-      if (areEqual) {
-        toRemove.push(i);
-      }
-    }
-
-    toRemove.forEach((x) => plugins.splice(x, 1));
+    },
+    IfStatement() {
+      isStatement = true;
+    },
   });
+  let flags = 0;
+  if (!isFunctionCall) {
+    flags = flags | FUNCTIONLESS_FLAG;
+  }
+  if (!isStatement) {
+    flags = flags | STATEMENTLESS_FLAG;
+  }
+  return flags;
 }
 
-module.exports = function({ types: t }) {
+module.exports = function ({ types: t }) {
   return {
     pre() {
       // allows adding custom globals such as host-functions
       if (this.opts != null && Array.isArray(this.opts.globals)) {
         this.opts.globals.forEach((name) => {
-          globals.add(name)
-        })
+          globals.add(name);
+        });
       }
     },
     visitor: {
       CallExpression: {
-        exit(path, state) {
+        enter(path, state) {
           processWorklets(t, path, state.file.opts.filename);
         },
       },
       'FunctionDeclaration|FunctionExpression|ArrowFunctionExpression': {
-        exit(path, state) {
-          processIfWorkletNode(t, path, state.file.opts.filename);
+        enter(path, state) {
+          const fileName = state.file.opts.filename;
+          processIfWorkletNode(t, path, fileName);
+          processIfGestureHandlerEventCallbackFunctionNode(t, path, fileName);
         },
       },
     },
-    // In this way we can modify babel options
-    // https://github.com/babel/babel/blob/eea156b2cb8deecfcf82d52aa1b71ba4995c7d68/packages/babel-core/src/transformation/normalize-opts.js#L64
-    manipulateOptions(opts, parserOpts) {
-      const plugins = opts.plugins;
-      removePluginsFromBlacklist(plugins);
-    },
   };
 };
\ No newline at end of file
